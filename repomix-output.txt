This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-25T19:59:51.788Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  entities/
    obstacle.py
    player.py
  states/
    game_over_state.py
    playing_state.py
    state_machine.py
    title_state.py
  tests/
    test_obstacle.py
    test_player.py
  utils/
    helpers.py
    logger.py
  assets.py
  main.py
  settings.py
.gitignore
LICENSE.md
README.md
requirements.txt

================================================================
Repository Files
================================================================

================
File: src/entities/obstacle.py
================
# src/entities/obstacle.py
import pygame as pg
from ..settings import SCREEN_HEIGHT

class Obstacle(pg.sprite.Sprite):
    def __init__(self, x, speed, assets):
        super().__init__()
        self.images = assets.get_image('fire')  # List of fire images
        self.current_image = 0
        self.animation_speed = 0.15
        self.animation_timer = 0
        self.rect = self.images[0].get_rect(midbottom=(x, SCREEN_HEIGHT - 48))
        self.speed = speed
        self.pipe_image = assets.get_image('pipe')

    def update(self):
        self.rect.x -= self.speed
        if self.rect.right < 0:
            self.kill()
        self.animation_timer += self.animation_speed
        if self.animation_timer >= 1:
            self.animation_timer = 0
            self.current_image = (self.current_image + 1) % len(self.images)

    def draw(self, surface):
        image = self.images[self.current_image]
        surface.blit(image, self.rect)
        pipe_rect = self.pipe_image.get_rect(midtop=(self.rect.centerx, self.rect.bottom))
        surface.blit(self.pipe_image, pipe_rect)

================
File: src/entities/player.py
================
# src/entities/player.py
import pygame as pg
from ..settings import SCREEN_WIDTH, SCREEN_HEIGHT

class Player(pg.sprite.Sprite):
    def __init__(self, x, y, assets):
        super().__init__()
        self.image = assets.get_image('man')
        self.rect = self.image.get_rect(topleft=(x, y))
        self.vel_y = 0
        self.is_jumping = False
        self.assets = assets

    def update(self, keys_pressed):
        if not self.is_jumping:
            if keys_pressed[pg.K_SPACE] or keys_pressed[pg.K_UP]:
                self.is_jumping = True
                self.vel_y = -18
        if self.is_jumping:
            self.vel_y += 0.6  # Gravity
            self.rect.y += self.vel_y
            if self.rect.bottom >= SCREEN_HEIGHT - 48:
                self.rect.bottom = SCREEN_HEIGHT - 48
                self.is_jumping = False
                self.vel_y = 0
        if keys_pressed[pg.K_LEFT]:
            self.rect.x -= 7
            if self.rect.left < 0:
                self.rect.left = 0
        if keys_pressed[pg.K_RIGHT]:
            self.rect.x += 7
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH

================
File: src/states/game_over_state.py
================
# src/states/game_over_state.py
import pygame as pg
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class GameOverState:
    def __init__(self, state_machine, assets):
        self.state_machine = state_machine
        self.assets = assets
        self.font = self.assets.get_font(72)
        self.game_over_text = self.font.render('GAME OVER', True, (236, 28, 36))
        self.restart_button_rect = pg.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2, 200, 50)

    def update(self, dt, events):
        for event in events:
            if event.type == pg.MOUSEBUTTONDOWN:
                if self.restart_button_rect.collidepoint(event.pos):
                    from states.playing_state import PlayingState
                    self.state_machine.add_state('playing', PlayingState(self.state_machine, self.assets))
                    self.state_machine.change_state('playing')

    def draw(self, surface):
        surface.fill((0, 0, 0))
        surface.blit(self.game_over_text, (SCREEN_WIDTH // 2 - self.game_over_text.get_width() // 2, 100))
        pg.draw.rect(surface, (255, 255, 255), self.restart_button_rect)
        restart_text = self.font.render('RESTART', True, (0, 0, 0))
        surface.blit(restart_text, (self.restart_button_rect.centerx - restart_text.get_width() // 2, self.restart_button_rect.centery - restart_text.get_height() // 2))

================
File: src/states/playing_state.py
================
# src/states/playing_state.py
import pygame as pg
import random
from ..entities.player import Player
from ..entities.obstacle import Obstacle
from ..settings import SCREEN_WIDTH, SCREEN_HEIGHT
from .game_over_state import GameOverState

class PlayingState:
    def __init__(self, state_machine, assets):
        self.state_machine = state_machine
        self.assets = assets
        player_start_x = SCREEN_WIDTH * 0.1
        player_start_y = SCREEN_HEIGHT - 48 - self.assets.get_image('man').get_height()
        self.player = Player(player_start_x, player_start_y, self.assets)
        self.obstacles = pg.sprite.Group()
        self.bg_x = 0
        self.bg_speed = 6
        self.score = 0
        self.last_obstacle_time = pg.time.get_ticks()
        self.obstacle_interval = 1000
        self.start_time = pg.time.get_ticks()

    def update(self, dt, events):
        keys_pressed = pg.key.get_pressed()
        self.player.update(keys_pressed)
        self.bg_x -= self.bg_speed
        bg_width = self.assets.get_image('bg1').get_width()
        if self.bg_x <= -bg_width:
            self.bg_x = 0
        current_time = pg.time.get_ticks()
        if current_time - self.last_obstacle_time > self.obstacle_interval:
            obstacle_x = SCREEN_WIDTH + random.randint(0, 200)
            obstacle = Obstacle(obstacle_x, self.bg_speed, self.assets)
            self.obstacles.add(obstacle)
            self.last_obstacle_time = current_time
        self.obstacles.update()
        if pg.sprite.spritecollideany(self.player, self.obstacles):
            self.state_machine.add_state('game_over', GameOverState(self.state_machine, self.assets, self.score))
            self.state_machine.change_state('game_over')
        self.score += 1

    def draw(self, surface):
        bg1 = self.assets.get_image('bg1')
        surface.blit(bg1, (self.bg_x, 0))
        surface.blit(bg1, (self.bg_x + bg1.get_width(), 0))
        surface.blit(self.player.image, self.player.rect)
        for obstacle in self.obstacles:
            obstacle.draw(surface)
        score_text = self.assets.get_font(48).render(str(self.score), True, (0, 0, 0))
        surface.blit(score_text, (20, 20))

================
File: src/states/state_machine.py
================
# src/states/state_machine.py
class StateMachine:
    def __init__(self):
        self.states = {}
        self.current_state = None

    def add_state(self, name, state):
        self.states[name] = state

    def change_state(self, name):
        self.current_state = self.states[name]

    def update(self, dt, events):
        if self.current_state:
            self.current_state.update(dt, events)

    def draw(self, surface):
        if self.current_state:
            self.current_state.draw(surface)

================
File: src/states/title_state.py
================
# src/states/title_state.py
import pygame as pg
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class TitleState:
    def __init__(self, state_machine, assets):
        self.state_machine = state_machine
        self.assets = assets
        self.font = self.assets.get_font(72)
        self.title_text = self.font.render('BIPPY', True, (236, 180, 28))
        self.play_button_rect = pg.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2, 200, 50)

    def update(self, dt, events):
        for event in events:
            if event.type == pg.MOUSEBUTTONDOWN:
                if self.play_button_rect.collidepoint(event.pos):
                    from states.playing_state import PlayingState
                    self.state_machine.add_state('playing', PlayingState(self.state_machine, self.assets))
                    self.state_machine.change_state('playing')

    def draw(self, surface):
        surface.fill((0, 0, 0))
        surface.blit(self.title_text, (SCREEN_WIDTH // 2 - self.title_text.get_width() // 2, 100))
        pg.draw.rect(surface, (255, 255, 255), self.play_button_rect)
        play_text = self.font.render('PLAY', True, (0, 0, 0))
        surface.blit(play_text, (self.play_button_rect.centerx - play_text.get_width() // 2, self.play_button_rect.centery - play_text.get_height() // 2))

================
File: src/tests/test_obstacle.py
================
# tests/test_obstacle.py
import unittest
import pygame as pg
from src.entities.obstacle import Obstacle
from src.assets import AssetManager

class TestObstacle(unittest.TestCase):
    def setUp(self):
        pg.init()
        self.assets = AssetManager()
        self.obstacle = Obstacle(500, self.assets)

    def test_initial_position(self):
        self.assertEqual(self.obstacle.rect.x, 500)

    def test_movement(self):
        initial_x = self.obstacle.rect.x
        self.obstacle.update(0.016)
        self.assertLess(self.obstacle.rect.x, initial_x)

if __name__ == '__main__':
    unittest.main()

================
File: src/tests/test_player.py
================
# tests/test_player.py
import unittest
import pygame as pg
from src.entities.player import Player
from src.assets import AssetManager

class TestPlayer(unittest.TestCase):
    def setUp(self):
        pg.init()
        self.assets = AssetManager()
        self.player = Player(100, 100, self.assets)

    def test_initial_position(self):
        self.assertEqual(self.player.rect.topleft, (100, 100))

    def test_jump(self):
        self.player.is_jumping = False
        self.player.vel_y = 0
        keys = {pg.K_SPACE: True}
        self.player.update(0, keys)
        self.assertTrue(self.player.is_jumping)
        self.assertEqual(self.player.vel_y, -18)

if __name__ == '__main__':
    unittest.main()

================
File: src/utils/helpers.py
================
# src/utils/helpers.py

def clamp(value, min_value, max_value):
    return max(min_value, min(value, max_value))

================
File: src/utils/logger.py
================
# src/utils/logger.py
import logging

logging.basicConfig(level=logging.DEBUG, filename='game.log', filemode='w',
                    format='%(name)s - %(levelname)s - %(message)s')

logger = logging.getLogger('BippyGame')

================
File: src/assets.py
================
# src/assets.py

import pygame as pg
import os
from .settings import IMAGE_DIR, SOUND_DIR, FONT_DIR, SCREEN_WIDTH, SCREEN_HEIGHT

class AssetManager:
    def __init__(self):
        self.images = {}
        self.sounds = {}
        self.fonts = {}
        self.load_assets()
    
    def load_assets(self):
        # Load images
        self.images['button'] = pg.image.load(os.path.join(IMAGE_DIR, 'button.png')).convert_alpha()
        self.images['buttonPress'] = pg.image.load(os.path.join(IMAGE_DIR, 'buttonPress.png')).convert_alpha()
        
        # Scale images proportionally
        self.images['man'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'man.png')).convert_alpha(), (100, 92))
        self.images['manSad'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'manSad.png')).convert_alpha(), (256, 256))
        self.images['bg'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'bg.png')).convert_alpha(), (SCREEN_WIDTH, SCREEN_HEIGHT))
        self.images['girl'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'girl.png')).convert_alpha(), (108, 92))
        self.images['villain'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'villain.png')).convert_alpha(), (82, 120))
        self.images['bg1'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'bg1.png')).convert_alpha(), (SCREEN_WIDTH, SCREEN_HEIGHT))
        self.images['space'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'space.png')).convert_alpha(), (800, 200))
        self.images['spacePress'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'spacePress.png')).convert_alpha(), (800, 200))
        self.images['keyboard'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'keyboard.png')).convert_alpha(), (590, 200))
        self.images['upPress'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'upPress.png')).convert_alpha(), (196, 98))
        self.images['leftPress'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'leftPress.png')).convert_alpha(), (190, 200))
        self.images['rightPress'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'rightPress.png')).convert_alpha(), (190, 200))
        
        # Load fire images
        self.images['fire'] = [
            pg.transform.scale(
                pg.image.load(os.path.join(IMAGE_DIR, 'fire1.png')).convert_alpha(), (84, 100)),
            pg.transform.scale(
                pg.image.load(os.path.join(IMAGE_DIR, 'fire2.png')).convert_alpha(), (90, 100)),
            pg.transform.scale(
                pg.image.load(os.path.join(IMAGE_DIR, 'fire3.png')).convert_alpha(), (90, 100)),
        ]
        self.images['pipe'] = pg.transform.scale(
            pg.image.load(os.path.join(IMAGE_DIR, 'pipe.png')).convert_alpha(), (96, 192))
        
        # Load fonts
        self.fonts['large'] = os.path.join(FONT_DIR, 'font.ttf')
        self.fonts['medium'] = os.path.join(FONT_DIR, 'font.ttf')
        self.fonts['small'] = os.path.join(FONT_DIR, 'font.ttf')
        
        # Pre-render texts
        self.pre_render_texts()
    
    def pre_render_texts(self):
        # Create font objects
        font_large = pg.font.Font(self.fonts['large'], 228)
        font_medium = pg.font.Font(self.fonts['medium'], 48)
        font_small = pg.font.Font(self.fonts['small'], 36)
        
        # Render texts
        self.images['play_text'] = font_medium.render('PLAY!', True, (0, 0, 0))
        self.images['controls_text'] = font_medium.render('CONTROLS', True, (0, 0, 0))
        self.images['title_text'] = font_large.render('BIPPY', True, (236, 180, 28))
        self.images['go_text'] = font_large.render('SAVE FIPPY!', True, (236, 180, 28))
        self.images['end_text'] = font_large.render('GAME OVER', True, (236, 180, 28))
        self.images['jump_text'] = font_medium.render('JUMP - space bar or up arrow', True, (0, 0, 0))
        self.images['move_text'] = font_medium.render('MOVE - left or right arrow', True, (0, 0, 0))
        self.images['back_text'] = font_small.render('BACK', True, (0, 0, 0))
        self.images['restart_text'] = font_medium.render('RESTART', True, (0, 0, 0))
        # Dialogue Texts
        self.images['fippy1_text'] = font_medium.render('Hey Bippy <3', True, (0, 0, 0))
        self.images['fippy2_text'] = font_medium.render('AHHH! HELP!', True, (0, 0, 0))
        self.images['bippy1_text'] = font_medium.render('Hey Fippy <3', True, (0, 0, 0))
        self.images['bippy2_text'] = font_medium.render('FIPPY WATCH OUT!', True, (0, 0, 0))
        self.images['bippy3_text'] = font_medium.render('I\'LL SAVE YOU!', True, (0, 0, 0))
        self.images['villain1_text'] = font_medium.render('I got you now Fippy!', True, (0, 0, 0))
    
    def get_image(self, key):
        return self.images.get(key)
    
    def get_font(self, size):
        return pg.font.Font(self.fonts['medium'], size)

================
File: src/main.py
================
# src/main.py
import pygame as pg
from .settings import SCREEN_WIDTH, SCREEN_HEIGHT, TITLE, FPS
from .assets import AssetManager
from .states.state_machine import StateMachine
from .states.title_state import TitleState

def main():
    pg.init()
    screen = pg.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pg.display.set_caption(TITLE)
    clock = pg.time.Clock()
    assets = AssetManager()
    state_machine = StateMachine()
    state_machine.add_state('title', TitleState(state_machine, assets))
    state_machine.change_state('title')
    running = True
    while running:
        dt = clock.tick(FPS) / 1000
        events = pg.event.get()
        for event in events:
            if event.type == pg.QUIT:
                running = False
        state_machine.update(dt, events)
        state_machine.draw(screen)
        pg.display.flip()
    pg.quit()

if __name__ == '__main__':
    main()

================
File: src/settings.py
================
# src/settings.py
import os

# Screen settings
SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 800
FPS = 60
TITLE = 'Bippy Game'

# Base directory (adjust as needed)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Asset directories
ASSETS_DIR = os.path.join(BASE_DIR, 'assets')
IMAGE_DIR = os.path.join(ASSETS_DIR, 'images')
SOUND_DIR = os.path.join(ASSETS_DIR, 'sounds')
FONT_DIR = os.path.join(ASSETS_DIR, 'fonts')

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]

# Virtual environment
venv/
env/

# System files
.DS_Store

# Log files
logs/
*.log

# Ignore backup or temporary files
*.bak
*.tmp

repomix-output.txt

================
File: LICENSE.md
================
MIT License

Copyright 2024 AARON PERKEL

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: README.md
================
# Bippy Game

A side-scrolling platformer where you control **Bippy** on a mission to save **Fippy** from the villain. Jump over obstacles and avoid hazards to reach your goal.

## Description

**Bippy** is an engaging side-scrolling platformer built with Python and Pygame. Embark on an adventurous quest with Bippy as you navigate through obstacles to rescue Fippy from the clutches of the villain.

## Installation

### Prerequisites

- **Python 3.6** or higher

### Steps

1. **Clone the Repository**
    ```bash
    git clone https://github.com/aaronperkel/bippy
    ```

2. **Navigate to the Project Directory**
    ```bash
    cd bippy
    ```

3. **Set Up Python Virtual Environment**
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    pip install -r requirements.txt
    ```

4. **Install Dependencies**
    ```bash
    pip install -r requirements.txt
    ```

## Author
- Aaron Perkel
-   Date: November 2024

## License
This project is licensed under the [MIT License](LICENSE.md).

## Enjoy playing Bippy Game!
For any questions or issues, please contact me@aaronperkel.com

================
File: requirements.txt
================
pygame>=2.0.0
