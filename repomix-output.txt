This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-25T19:53:55.313Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  entities/
    obstacle.py
    player.py
  states/
    game_over_state.py
    playing_state.py
    state_machine.py
    title_state.py
  tests/
    test_obstacle.py
    test_player.py
  utils/
    helpers.py
    logger.py
  assets.py
  main.py
  settings.py
.gitignore
LICENSE.md
old.py
README.md
requirements.txt

================================================================
Repository Files
================================================================

================
File: src/entities/obstacle.py
================
# src/entities/obstacle.py
import pygame as pg
from ..settings import SCREEN_HEIGHT

class Obstacle(pg.sprite.Sprite):
    def __init__(self, x, speed, assets):
        super().__init__()
        self.images = assets.get_image('fire')  # List of fire images
        self.current_image = 0
        self.animation_speed = 0.15
        self.animation_timer = 0
        self.rect = self.images[0].get_rect(midbottom=(x, SCREEN_HEIGHT - 48))
        self.speed = speed
        self.pipe_image = assets.get_image('pipe')

    def update(self):
        self.rect.x -= self.speed
        if self.rect.right < 0:
            self.kill()
        self.animation_timer += self.animation_speed
        if self.animation_timer >= 1:
            self.animation_timer = 0
            self.current_image = (self.current_image + 1) % len(self.images)

    def draw(self, surface):
        image = self.images[self.current_image]
        surface.blit(image, self.rect)
        pipe_rect = self.pipe_image.get_rect(midtop=(self.rect.centerx, self.rect.bottom))
        surface.blit(self.pipe_image, pipe_rect)

================
File: src/entities/player.py
================
# src/entities/player.py
import pygame as pg
from ..settings import SCREEN_WIDTH, SCREEN_HEIGHT

class Player(pg.sprite.Sprite):
    def __init__(self, x, y, assets):
        super().__init__()
        self.image = assets.get_image('man')
        self.rect = self.image.get_rect(topleft=(x, y))
        self.vel_y = 0
        self.is_jumping = False
        self.assets = assets

    def update(self, keys_pressed):
        if not self.is_jumping:
            if keys_pressed[pg.K_SPACE] or keys_pressed[pg.K_UP]:
                self.is_jumping = True
                self.vel_y = -18
        if self.is_jumping:
            self.vel_y += 0.6  # Gravity
            self.rect.y += self.vel_y
            if self.rect.bottom >= SCREEN_HEIGHT - 48:
                self.rect.bottom = SCREEN_HEIGHT - 48
                self.is_jumping = False
                self.vel_y = 0
        if keys_pressed[pg.K_LEFT]:
            self.rect.x -= 7
            if self.rect.left < 0:
                self.rect.left = 0
        if keys_pressed[pg.K_RIGHT]:
            self.rect.x += 7
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH

================
File: src/states/game_over_state.py
================
# src/states/game_over_state.py
import pygame as pg
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class GameOverState:
    def __init__(self, state_machine, assets):
        self.state_machine = state_machine
        self.assets = assets
        self.font = self.assets.get_font(72)
        self.game_over_text = self.font.render('GAME OVER', True, (236, 28, 36))
        self.restart_button_rect = pg.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2, 200, 50)

    def update(self, dt, events):
        for event in events:
            if event.type == pg.MOUSEBUTTONDOWN:
                if self.restart_button_rect.collidepoint(event.pos):
                    from states.playing_state import PlayingState
                    self.state_machine.add_state('playing', PlayingState(self.state_machine, self.assets))
                    self.state_machine.change_state('playing')

    def draw(self, surface):
        surface.fill((0, 0, 0))
        surface.blit(self.game_over_text, (SCREEN_WIDTH // 2 - self.game_over_text.get_width() // 2, 100))
        pg.draw.rect(surface, (255, 255, 255), self.restart_button_rect)
        restart_text = self.font.render('RESTART', True, (0, 0, 0))
        surface.blit(restart_text, (self.restart_button_rect.centerx - restart_text.get_width() // 2, self.restart_button_rect.centery - restart_text.get_height() // 2))

================
File: src/states/playing_state.py
================
# src/states/playing_state.py
import pygame as pg
import random
from ..entities.player import Player
from ..entities.obstacle import Obstacle
from ..settings import SCREEN_WIDTH, SCREEN_HEIGHT
from .game_over_state import GameOverState

class PlayingState:
    def __init__(self, state_machine, assets):
        self.state_machine = state_machine
        self.assets = assets
        player_start_x = SCREEN_WIDTH * 0.1
        player_start_y = SCREEN_HEIGHT - 48 - self.assets.get_image('man').get_height()
        self.player = Player(player_start_x, player_start_y, self.assets)
        self.obstacles = pg.sprite.Group()
        self.bg_x = 0
        self.bg_speed = 6
        self.score = 0
        self.last_obstacle_time = pg.time.get_ticks()
        self.obstacle_interval = 1000
        self.start_time = pg.time.get_ticks()

    def update(self, dt, events):
        keys_pressed = pg.key.get_pressed()
        self.player.update(keys_pressed)
        self.bg_x -= self.bg_speed
        bg_width = self.assets.get_image('bg1').get_width()
        if self.bg_x <= -bg_width:
            self.bg_x = 0
        current_time = pg.time.get_ticks()
        if current_time - self.last_obstacle_time > self.obstacle_interval:
            obstacle_x = SCREEN_WIDTH + random.randint(0, 200)
            obstacle = Obstacle(obstacle_x, self.bg_speed, self.assets)
            self.obstacles.add(obstacle)
            self.last_obstacle_time = current_time
        self.obstacles.update()
        if pg.sprite.spritecollideany(self.player, self.obstacles):
            self.state_machine.add_state('game_over', GameOverState(self.state_machine, self.assets, self.score))
            self.state_machine.change_state('game_over')
        self.score += 1

    def draw(self, surface):
        bg1 = self.assets.get_image('bg1')
        surface.blit(bg1, (self.bg_x, 0))
        surface.blit(bg1, (self.bg_x + bg1.get_width(), 0))
        surface.blit(self.player.image, self.player.rect)
        for obstacle in self.obstacles:
            obstacle.draw(surface)
        score_text = self.assets.get_font(48).render(str(self.score), True, (0, 0, 0))
        surface.blit(score_text, (20, 20))

================
File: src/states/state_machine.py
================
# src/states/state_machine.py
class StateMachine:
    def __init__(self):
        self.states = {}
        self.current_state = None

    def add_state(self, name, state):
        self.states[name] = state

    def change_state(self, name):
        self.current_state = self.states[name]

    def update(self, dt, events):
        if self.current_state:
            self.current_state.update(dt, events)

    def draw(self, surface):
        if self.current_state:
            self.current_state.draw(surface)

================
File: src/states/title_state.py
================
# src/states/title_state.py
import pygame as pg
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class TitleState:
    def __init__(self, state_machine, assets):
        self.state_machine = state_machine
        self.assets = assets
        self.font = self.assets.get_font(72)
        self.title_text = self.font.render('BIPPY', True, (236, 180, 28))
        self.play_button_rect = pg.Rect(SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2, 200, 50)

    def update(self, dt, events):
        for event in events:
            if event.type == pg.MOUSEBUTTONDOWN:
                if self.play_button_rect.collidepoint(event.pos):
                    from states.playing_state import PlayingState
                    self.state_machine.add_state('playing', PlayingState(self.state_machine, self.assets))
                    self.state_machine.change_state('playing')

    def draw(self, surface):
        surface.fill((0, 0, 0))
        surface.blit(self.title_text, (SCREEN_WIDTH // 2 - self.title_text.get_width() // 2, 100))
        pg.draw.rect(surface, (255, 255, 255), self.play_button_rect)
        play_text = self.font.render('PLAY', True, (0, 0, 0))
        surface.blit(play_text, (self.play_button_rect.centerx - play_text.get_width() // 2, self.play_button_rect.centery - play_text.get_height() // 2))

================
File: src/tests/test_obstacle.py
================
# tests/test_obstacle.py
import unittest
import pygame as pg
from src.entities.obstacle import Obstacle
from src.assets import AssetManager

class TestObstacle(unittest.TestCase):
    def setUp(self):
        pg.init()
        self.assets = AssetManager()
        self.obstacle = Obstacle(500, self.assets)

    def test_initial_position(self):
        self.assertEqual(self.obstacle.rect.x, 500)

    def test_movement(self):
        initial_x = self.obstacle.rect.x
        self.obstacle.update(0.016)
        self.assertLess(self.obstacle.rect.x, initial_x)

if __name__ == '__main__':
    unittest.main()

================
File: src/tests/test_player.py
================
# tests/test_player.py
import unittest
import pygame as pg
from src.entities.player import Player
from src.assets import AssetManager

class TestPlayer(unittest.TestCase):
    def setUp(self):
        pg.init()
        self.assets = AssetManager()
        self.player = Player(100, 100, self.assets)

    def test_initial_position(self):
        self.assertEqual(self.player.rect.topleft, (100, 100))

    def test_jump(self):
        self.player.is_jumping = False
        self.player.vel_y = 0
        keys = {pg.K_SPACE: True}
        self.player.update(0, keys)
        self.assertTrue(self.player.is_jumping)
        self.assertEqual(self.player.vel_y, -18)

if __name__ == '__main__':
    unittest.main()

================
File: src/utils/helpers.py
================
# src/utils/helpers.py

def clamp(value, min_value, max_value):
    return max(min_value, min(value, max_value))

================
File: src/utils/logger.py
================
# src/utils/logger.py
import logging

logging.basicConfig(level=logging.DEBUG, filename='game.log', filemode='w',
                    format='%(name)s - %(levelname)s - %(message)s')

logger = logging.getLogger('BippyGame')

================
File: src/assets.py
================
# src/assets.py
import pygame as pg
import os
from .settings import IMAGE_DIR, SOUND_DIR, FONT_DIR

class AssetManager:
    def __init__(self):
        self.images = {}
        self.sounds = {}
        self.fonts = {}
        self.load_assets()
    
    def load_assets(self):
        # Load images
        self.images['button'] = pg.image.load(os.path.join(IMAGE_DIR, 'button.png')).convert_alpha()
        self.images['buttonPress'] = pg.image.load(os.path.join(IMAGE_DIR, 'buttonPress.png')).convert_alpha()
        # Scale images proportionally
        self.images['man'] = pg.transform.scale(pg.image.load(os.path.join(IMAGE_DIR, 'man.png')).convert_alpha(), (100, 92))
        self.images['manSad'] = pg.transform.scale(pg.image.load(os.path.join(IMAGE_DIR, 'manSad.png')).convert_alpha(), (256, 256))
        # Load other images similarly...

        # Load fire images
        self.images['fire'] = [
            pg.transform.scale(pg.image.load(os.path.join(IMAGE_DIR, 'fire1.png')).convert_alpha(), (84, 100)),
            pg.transform.scale(pg.image.load(os.path.join(IMAGE_DIR, 'fire2.png')).convert_alpha(), (90, 100)),
            pg.transform.scale(pg.image.load(os.path.join(IMAGE_DIR, 'fire3.png')).convert_alpha(), (90, 100)),
        ]
        self.images['pipe'] = pg.transform.scale(pg.image.load(os.path.join(IMAGE_DIR, 'pipe.png')).convert_alpha(), (96, 192))

        # Load fonts
        self.fonts['large'] = os.path.join(FONT_DIR, 'font.ttf')
        self.fonts['medium'] = os.path.join(FONT_DIR, 'font.ttf')
        self.fonts['small'] = os.path.join(FONT_DIR, 'font.ttf')

        # Pre-render texts
        self.pre_render_texts()

    def pre_render_texts(self):
        # Create font objects
        font_large = pg.font.Font(self.fonts['large'], 228)
        font_medium = pg.font.Font(self.fonts['medium'], 48)
        font_small = pg.font.Font(self.fonts['small'], 36)
        
        # Render texts
        self.images['play_text'] = font_medium.render('PLAY!', True, (0, 0, 0))
        self.images['controls_text'] = font_medium.render('CONTROLS', True, (0, 0, 0))
        self.images['title_text'] = font_large.render('BIPPY', True, (236, 180, 28))
        # Continue rendering other texts...

    def get_image(self, key):
        return self.images.get(key)
    
    def get_font(self, size):
        return pg.font.Font(self.fonts['medium'], size)

================
File: src/main.py
================
# src/main.py
import pygame as pg
from .settings import SCREEN_WIDTH, SCREEN_HEIGHT, TITLE, FPS
from .assets import AssetManager
from .states.state_machine import StateMachine
from .states.title_state import TitleState

def main():
    pg.init()
    screen = pg.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pg.display.set_caption(TITLE)
    clock = pg.time.Clock()
    assets = AssetManager()
    state_machine = StateMachine()
    state_machine.add_state('title', TitleState(state_machine, assets))
    state_machine.change_state('title')
    running = True
    while running:
        dt = clock.tick(FPS) / 1000
        events = pg.event.get()
        for event in events:
            if event.type == pg.QUIT:
                running = False
        state_machine.update(dt, events)
        state_machine.draw(screen)
        pg.display.flip()
    pg.quit()

if __name__ == '__main__':
    main()

================
File: src/settings.py
================
# src/settings.py
import os

# Screen settings
SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 800
FPS = 60
TITLE = 'Bippy Game'

# Paths
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
ASSETS_DIR = os.path.join(BASE_DIR, 'assets')
IMAGE_DIR = os.path.join(ASSETS_DIR, 'images')
SOUND_DIR = os.path.join(ASSETS_DIR, 'sounds')
FONT_DIR = os.path.join(ASSETS_DIR, 'fonts')

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]

# Virtual environment
venv/
env/

# System files
.DS_Store

# Log files
logs/
*.log

# Ignore backup or temporary files
*.bak
*.tmp

repomix-output.txt

================
File: LICENSE.md
================
MIT License

Copyright 2024 AARON PERKEL

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: old.py
================
"""
Bippy Game

A side-scrolling platformer where you control Bippy on a mission to save Fippy from the villain.
Jump over obstacles and avoid hazards to reach your goal.

Author: Aaron Perkel
Date: November 2024
"""

import pygame as pg
import sys
import random

# Constants
SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 800
FPS = 60

# Initialize Pygame
pg.init()
screen = pg.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pg.display.set_caption('Bippy')
clock = pg.time.Clock()

# Game States
TITLE = 'title'
CONTROLS = 'controls'
INTRO = 'intro'
PLAYING = 'playing'
GAME_OVER = 'game_over'

# Assets Loading Function
def load_assets():
    assets = {}
    # Load images
    assets['button'] = pg.image.load('textures/button.png')
    assets['buttonPress'] = pg.image.load('textures/buttonPress.png')
    # Scale images proportionally
    assets['man'] = pg.transform.scale(pg.image.load('textures/man.png'), (100, 92))
    assets['manSad'] = pg.transform.scale(pg.image.load('textures/manSad.png'), (256, 256))
    assets['bg'] = pg.transform.scale(pg.image.load('textures/bg.png'), (SCREEN_WIDTH, SCREEN_HEIGHT))
    assets['girl'] = pg.transform.scale(pg.image.load('textures/girl.png'), (108, 92))
    assets['villain'] = pg.transform.scale(pg.image.load('textures/villain.png'), (82, 120))
    assets['bg1'] = pg.transform.scale(pg.image.load('textures/bg1.png'), (SCREEN_WIDTH, SCREEN_HEIGHT))
    assets['space'] = pg.transform.scale(pg.image.load('textures/space.png'), (800, 200))
    assets['spacePress'] = pg.transform.scale(pg.image.load('textures/spacePress.png'), (800, 200))
    assets['keyboard'] = pg.transform.scale(pg.image.load('textures/keyboard.png'), (590, 200))
    assets['upPress'] = pg.transform.scale(pg.image.load('textures/upPress.png'), (196, 98))
    assets['leftPress'] = pg.transform.scale(pg.image.load('textures/leftPress.png'), (190, 200))
    assets['rightPress'] = pg.transform.scale(pg.image.load('textures/rightPress.png'), (190, 200))
    # Scale fire images
    assets['fire'] = [
        pg.transform.scale(pg.image.load('textures/fire1.png'), (84, 100)),
        pg.transform.scale(pg.image.load('textures/fire2.png'), (90, 100)),
        pg.transform.scale(pg.image.load('textures/fire3.png'), (90, 100)),
    ]
    assets['pipe'] = pg.transform.scale(pg.image.load('textures/pipe.png'), (96, 192))
    # Load fonts
    assets['font_large'] = pg.font.Font('textures/font.ttf', 228)
    assets['font_medium'] = pg.font.Font('textures/font.ttf', 48)
    assets['font_small'] = pg.font.Font('textures/font.ttf', 36)
    # Text Renderings
    assets['play_text'] = assets['font_medium'].render('PLAY!', True, (0, 0, 0))
    assets['controls_text'] = assets['font_medium'].render('CONTROLS', True, (0, 0, 0))
    assets['title_text'] = assets['font_large'].render('BIPPY', True, (236, 180, 28))
    assets['go_text'] = assets['font_large'].render('SAVE FIPPY!', True, (236, 180, 28))
    assets['end_text'] = assets['font_large'].render('GAME OVER', True, (236, 180, 28))
    assets['jump_text'] = assets['font_medium'].render('JUMP - space bar or up arrow', True, (0, 0, 0))
    assets['move_text'] = assets['font_medium'].render('MOVE - left or right arrow', True, (0, 0, 0))
    assets['back_text'] = assets['font_small'].render('BACK', True, (0, 0, 0))
    assets['restart_text'] = assets['font_medium'].render('RESTART', True, (0, 0, 0))
    # Dialogue Texts
    assets['fippy1_text'] = assets['font_medium'].render('Hey Bippy <3', True, (0, 0, 0))
    assets['fippy2_text'] = assets['font_medium'].render('AHHH! HELP!', True, (0, 0, 0))
    assets['bippy1_text'] = assets['font_medium'].render('Hey Fippy <3', True, (0, 0, 0))
    assets['bippy2_text'] = assets['font_medium'].render('FIPPY WATCH OUT!', True, (0, 0, 0))
    assets['bippy3_text'] = assets['font_medium'].render('I\'LL SAVE YOU!', True, (0, 0, 0))
    assets['villain1_text'] = assets['font_medium'].render('I got you now Fippy!', True, (0, 0, 0))
    return assets

# Object Classes
class Obstacle(pg.sprite.Sprite):
    def __init__(self, x, speed, assets):
        super().__init__()
        self.images = assets['fire']  # List of fire images for animation
        self.current_image = 0
        self.animation_speed = 0.15  # Adjust for animation speed
        self.animation_timer = 0
        self.rect = self.images[0].get_rect(midbottom=(x, SCREEN_HEIGHT - 48))
        self.speed = speed
        self.pipe_image = assets['pipe']

    def update(self):
        self.rect.x -= self.speed
        if self.rect.right < 0:
            self.kill()
        # Update animation
        self.animation_timer += self.animation_speed
        if self.animation_timer >= 1:
            self.animation_timer = 0
            self.current_image = (self.current_image + 1) % len(self.images)

    def draw(self, surface):
        # Draw the current image
        image = self.images[self.current_image]
        surface.blit(image, self.rect)
        # Draw the pipe
        pipe_rect = self.pipe_image.get_rect(midtop=(self.rect.centerx, self.rect.bottom))
        surface.blit(self.pipe_image, pipe_rect)

class Player(pg.sprite.Sprite):
    def __init__(self, x, y, assets):
        super().__init__()
        self.image = assets['man']
        self.rect = self.image.get_rect(topleft=(x, y))
        self.vel_y = 0
        self.is_jumping = False
        self.assets = assets

    def update(self, keys_pressed):
        if not self.is_jumping:
            if keys_pressed[pg.K_SPACE] or keys_pressed[pg.K_UP]:
                self.is_jumping = True
                self.vel_y = -18  # Increased for larger screen
        if self.is_jumping:
            self.vel_y += 0.6  # Gravity
            self.rect.y += self.vel_y
            if self.rect.bottom >= SCREEN_HEIGHT - 48:
                self.rect.bottom = SCREEN_HEIGHT - 48
                self.is_jumping = False
                self.vel_y = 0
        if keys_pressed[pg.K_LEFT]:
            self.rect.x -= 7
            if self.rect.left < 0:
                self.rect.left = 0
        if keys_pressed[pg.K_RIGHT]:
            self.rect.x += 7
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH

class Game:
    def __init__(self):
        self.assets = load_assets()
        self.state = TITLE
        player_start_x = SCREEN_WIDTH * 0.1
        player_start_y = SCREEN_HEIGHT - 48 - self.assets['man'].get_height()
        self.player = Player(player_start_x, player_start_y, self.assets)
        self.obstacles = pg.sprite.Group()
        self.bg_x = 0
        self.bg_speed = 6  # Increased for larger screen
        self.score = 0
        self.last_obstacle_time = 0
        self.obstacle_interval = 1000  # Decreased for more challenge
        self.start_time = pg.time.get_ticks()
        # Intro scene variables
        self.intro_player_x = -100
        self.intro_player_y = SCREEN_HEIGHT - 48 - self.assets['man'].get_height()
        self.intro_villain_x = SCREEN_WIDTH + 100
        self.intro_girl_x = SCREEN_WIDTH * 0.6
        self.intro_dialogue_time = pg.time.get_ticks()
        self.intro_stage = 0  # To keep track of dialogue stages

    def reset(self):
        player_start_x = SCREEN_WIDTH * 0.1
        player_start_y = SCREEN_HEIGHT - 48 - self.assets['man'].get_height()
        self.player = Player(player_start_x, player_start_y, self.assets)
        self.obstacles = pg.sprite.Group()
        self.bg_x = 0
        self.score = 0
        self.start_time = pg.time.get_ticks()
        self.last_obstacle_time = 0
        # Reset intro scene variables
        self.intro_player_x = -100
        self.intro_player_y = SCREEN_HEIGHT - 48 - self.assets['man'].get_height()
        self.intro_villain_x = SCREEN_WIDTH + 100
        self.intro_girl_x = SCREEN_WIDTH * 0.6
        self.intro_dialogue_time = pg.time.get_ticks()
        self.intro_stage = 0

    def run(self):
        running = True
        while running:
            keys_pressed = pg.key.get_pressed()
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    running = False
            if self.state == TITLE:
                self.title_screen()
            elif self.state == CONTROLS:
                self.controls_screen()
            elif self.state == INTRO:
                self.intro_screen()
            elif self.state == PLAYING:
                self.playing_screen(keys_pressed)
            elif self.state == GAME_OVER:
                self.game_over_screen()
            pg.display.flip()
            clock.tick(FPS)
        pg.quit()
        sys.exit()

    def title_screen(self):
        screen.blit(self.assets['bg'], (0, 0))
        # Draw Title
        title_text = self.assets['title_text']
        screen.blit(title_text, (SCREEN_WIDTH // 2 - title_text.get_width() // 2, SCREEN_HEIGHT * 0.2))
        # Draw Buttons
        button_width = 360
        button_height = 88
        button_x = SCREEN_WIDTH // 2 - button_width // 2
        play_button_y = SCREEN_HEIGHT * 0.5
        controls_button_y = play_button_y + button_height + 20

        play_button_rect = pg.Rect(button_x, play_button_y, button_width, button_height)
        controls_button_rect = pg.Rect(button_x, controls_button_y, button_width, button_height)

        mouse_x, mouse_y = pg.mouse.get_pos()
        pg.mouse.set_cursor(pg.SYSTEM_CURSOR_ARROW)
        if play_button_rect.collidepoint(mouse_x, mouse_y):
            pg.mouse.set_cursor(pg.SYSTEM_CURSOR_HAND)
            screen.blit(pg.transform.scale(self.assets['buttonPress'], (button_width, button_height)), play_button_rect.topleft)
            if pg.mouse.get_pressed()[0]:
                self.state = INTRO
                self.intro_dialogue_time = pg.time.get_ticks()
        else:
            screen.blit(pg.transform.scale(self.assets['button'], (button_width, button_height)), play_button_rect.topleft)
        if controls_button_rect.collidepoint(mouse_x, mouse_y):
            pg.mouse.set_cursor(pg.SYSTEM_CURSOR_HAND)
            screen.blit(pg.transform.scale(self.assets['buttonPress'], (button_width, button_height)), controls_button_rect.topleft)
            if pg.mouse.get_pressed()[0]:
                pass
                # self.state = CONTROLS
        else:
            screen.blit(pg.transform.scale(self.assets['button'], (button_width, button_height)), controls_button_rect.topleft)
        # Draw Button Text
        play_text = self.assets['play_text']
        controls_text = self.assets['controls_text']
        screen.blit(play_text, (play_button_rect.centerx - play_text.get_width() // 2, play_button_rect.centery - play_text.get_height() // 2))
        screen.blit(controls_text, (controls_button_rect.centerx - controls_text.get_width() // 2, controls_button_rect.centery - controls_text.get_height() // 2))

    def controls_screen(self):
        screen.fill((89, 153, 255))
        # Handle Back Button
        back_button_width = 240
        back_button_height = 58
        back_button_rect = pg.Rect(20, 20, back_button_width, back_button_height)
        mouse_x, mouse_y = pg.mouse.get_pos()
        pg.mouse.set_cursor(pg.SYSTEM_CURSOR_ARROW)
        if back_button_rect.collidepoint(mouse_x, mouse_y):
            pg.mouse.set_cursor(pg.SYSTEM_CURSOR_HAND)
            screen.blit(pg.transform.scale(self.assets['buttonPress'], (back_button_width, back_button_height)), back_button_rect.topleft)
            if pg.mouse.get_pressed()[0]:
                self.state = TITLE
        else:
            screen.blit(pg.transform.scale(self.assets['button'], (back_button_width, back_button_height)), back_button_rect.topleft)
        back_text = self.assets['back_text']
        screen.blit(back_text, (back_button_rect.centerx - back_text.get_width() // 2, back_button_rect.centery - back_text.get_height() // 2))
        # Display Controls
        keys = pg.key.get_pressed()
        screen.blit(self.assets['keyboard'], (SCREEN_WIDTH // 2 - self.assets['keyboard'].get_width() // 2, SCREEN_HEIGHT * 0.3))
        if keys[pg.K_SPACE]:
            screen.blit(self.assets['spacePress'], (SCREEN_WIDTH // 2 - self.assets['spacePress'].get_width() // 2, SCREEN_HEIGHT * 0.1))
        else:
            screen.blit(self.assets['space'], (SCREEN_WIDTH // 2 - self.assets['space'].get_width() // 2, SCREEN_HEIGHT * 0.1))
        if keys[pg.K_UP]:
            screen.blit(self.assets['upPress'], (SCREEN_WIDTH // 2 - self.assets['upPress'].get_width() // 2, SCREEN_HEIGHT * 0.3))
        if keys[pg.K_LEFT]:
            screen.blit(self.assets['leftPress'], (SCREEN_WIDTH // 2 - self.assets['keyboard'].get_width() // 2, SCREEN_HEIGHT * 0.3))
        if keys[pg.K_RIGHT]:
            screen.blit(self.assets['rightPress'], (SCREEN_WIDTH // 2 + self.assets['keyboard'].get_width() // 2 - self.assets['rightPress'].get_width(), SCREEN_HEIGHT * 0.3))
        # Instructions
        jump_text = self.assets['jump_text']
        move_text = self.assets['move_text']
        screen.blit(jump_text, (SCREEN_WIDTH // 2 - jump_text.get_width() // 2, SCREEN_HEIGHT * 0.7))
        screen.blit(move_text, (SCREEN_WIDTH // 2 - move_text.get_width() // 2, SCREEN_HEIGHT * 0.75))

    def intro_screen(self):
        # Intro scene logic
        current_time = pg.time.get_ticks()
        elapsed_time = (current_time - self.intro_dialogue_time) / 1000  # Convert to seconds
        screen.blit(self.assets['bg1'], (0, 0))
        pg.mouse.set_cursor(pg.SYSTEM_CURSOR_ARROW)
        keys = pg.key.get_pressed()

        # Draw characters
        screen.blit(self.assets['man'], (self.intro_player_x, self.intro_player_y))
        screen.blit(self.assets['girl'], (self.intro_girl_x, self.intro_player_y))
        screen.blit(self.assets['villain'], (self.intro_villain_x, self.intro_player_y - 30))

        # Bippy moves right
        if self.intro_player_x < SCREEN_WIDTH * 0.1:
            self.intro_player_x += 8
        else:
            self.intro_player_x = SCREEN_WIDTH * 0.1

        # Dialogue sequence
        if elapsed_time <= 1:
            # Fippy says "Hey Bippy <3"
            screen.blit(self.assets['fippy1_text'], (self.intro_girl_x + 50, self.intro_player_y - 50))
        elif elapsed_time <= 2:
            # Bippy says "Hey Fippy <3"
            screen.blit(self.assets['bippy1_text'], (self.intro_player_x, self.intro_player_y - 50))
        elif elapsed_time <= 3:
            # Villain moves towards Fippy
            if self.intro_villain_x > SCREEN_WIDTH * 0.7:
                self.intro_villain_x -= 8
            # Bippy says "FIPPY WATCH OUT!"
            screen.blit(self.assets['bippy2_text'], (self.intro_player_x, self.intro_player_y - 50))
        elif elapsed_time <= 4:
            # Villain says "I got you now Fippy!"
            screen.blit(self.assets['villain1_text'], (self.intro_villain_x - 80, self.intro_player_y - 80))
        elif elapsed_time <= 5:
            # Villain takes Fippy away
            self.intro_girl_x = self.intro_villain_x - self.assets['girl'].get_width()
            self.intro_villain_x += 8
            screen.blit(self.assets['fippy2_text'], (self.intro_girl_x - 40, self.intro_player_y - 50))
        elif elapsed_time <= 6:
            # Bippy says "I'LL SAVE YOU!"
            screen.blit(self.assets['bippy3_text'], (self.intro_player_x, self.intro_player_y - 50))
        else:
            # Start the game
            self.state = PLAYING
            self.start_time = pg.time.get_ticks()
            return

        # Allow skipping the intro with UP key
        if keys[pg.K_UP]:
            self.state = PLAYING
            self.start_time = pg.time.get_ticks()
            return

    def playing_screen(self, keys_pressed):
        # Background scrolling
        self.bg_x -= self.bg_speed
        bg_width = self.assets['bg1'].get_width()
        if self.bg_x <= -bg_width:
            self.bg_x = 0
        screen.blit(self.assets['bg1'], (self.bg_x, 0))
        screen.blit(self.assets['bg1'], (self.bg_x + bg_width, 0))
        # Update player
        self.player.update(keys_pressed)
        screen.blit(self.player.image, self.player.rect)
        # Spawn Obstacles
        current_time = pg.time.get_ticks()
        if current_time - self.last_obstacle_time > self.obstacle_interval:
            obstacle_x = SCREEN_WIDTH + random.randint(0, 200)
            obstacle = Obstacle(obstacle_x, self.bg_speed, self.assets)
            self.obstacles.add(obstacle)
            self.last_obstacle_time = current_time
        # Update Obstacles
        self.obstacles.update()
        for obstacle in self.obstacles:
            obstacle.draw(screen)
        # Collision Detection
        if pg.sprite.spritecollideany(self.player, self.obstacles):
            self.state = GAME_OVER
        # Update Score
        self.score += 1
        score_text = self.assets['font_medium'].render(str(self.score), True, (0, 0, 0))
        screen.blit(score_text, (20, 20))
        # Display "SAVE FIPPY!" for first few seconds
        elapsed_time = (current_time - self.start_time) / 1000
        if elapsed_time <= 3:
            go_text = self.assets['go_text']
            screen.blit(go_text, (SCREEN_WIDTH // 2 - go_text.get_width() // 2, 50))

    def game_over_screen(self):
        screen.fill((79, 112, 239))
        # Display Game Over Text
        game_over_text = self.assets['end_text']
        screen.blit(game_over_text, (SCREEN_WIDTH // 2 - game_over_text.get_width() // 2, 50))
        # Display Score
        score_text = self.assets['font_medium'].render(f'Your Score: {self.score}', True, (0, 0, 0))
        screen.blit(score_text, (SCREEN_WIDTH // 2 - score_text.get_width() // 2, 200))
        # Display Sad Bippy
        # screen.blit(self.assets['manSad'], (SCREEN_WIDTH // 2 - self.assets['manSad'].get_width() // 2, 140))
        # Restart Button
        button_width = 360
        button_height = 88
        restart_button_rect = pg.Rect(SCREEN_WIDTH // 2 - button_width // 2, SCREEN_HEIGHT * 0.6, button_width, button_height)
        mouse_x, mouse_y = pg.mouse.get_pos()
        pg.mouse.set_cursor(pg.SYSTEM_CURSOR_ARROW)
        if restart_button_rect.collidepoint(mouse_x, mouse_y):
            pg.mouse.set_cursor(pg.SYSTEM_CURSOR_HAND)
            screen.blit(pg.transform.scale(self.assets['buttonPress'], (button_width, button_height)), restart_button_rect.topleft)
            if pg.mouse.get_pressed()[0]:
                self.reset()
                self.state = TITLE
        else:
            screen.blit(pg.transform.scale(self.assets['button'], (button_width, button_height)), restart_button_rect.topleft)
        restart_text = self.assets['restart_text']
        screen.blit(restart_text, (restart_button_rect.centerx - restart_text.get_width() // 2, restart_button_rect.centery - restart_text.get_height() // 2))

if __name__ == '__main__':
    game = Game()
    game.run()

================
File: README.md
================
# Bippy Game

A side-scrolling platformer where you control **Bippy** on a mission to save **Fippy** from the villain. Jump over obstacles and avoid hazards to reach your goal.

## Description

**Bippy** is an engaging side-scrolling platformer built with Python and Pygame. Embark on an adventurous quest with Bippy as you navigate through obstacles to rescue Fippy from the clutches of the villain.

## Installation

### Prerequisites

- **Python 3.6** or higher

### Steps

1. **Clone the Repository**
    ```bash
    git clone https://github.com/aaronperkel/bippy
    ```

2. **Navigate to the Project Directory**
    ```bash
    cd bippy
    ```

3. **Set Up Python Virtual Environment**
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    pip install -r requirements.txt
    ```

4. **Install Dependencies**
    ```bash
    pip install -r requirements.txt
    ```

## Author
- Aaron Perkel
-   Date: November 2024

## License
This project is licensed under the [MIT License](LICENSE.md).

## Enjoy playing Bippy Game!
For any questions or issues, please contact me@aaronperkel.com

================
File: requirements.txt
================
pygame>=2.0.0
